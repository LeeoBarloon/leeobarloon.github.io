<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Leeo‘s Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://leeobarloon.github.io/"/>
  <updated>2016-01-24T13:45:21.000Z</updated>
  <id>http://leeobarloon.github.io/</id>
  
  <author>
    <name><![CDATA[LeeoBarloon]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Matplotlib安装和使用简要说明]]></title>
    <link href="http://leeobarloon.github.io/2016/01/24/Matplotlib%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E/"/>
    <id>http://leeobarloon.github.io/2016/01/24/Matplotlib安装和使用简要说明/</id>
    <published>2016-01-24T10:56:40.000Z</published>
    <updated>2016-01-24T13:45:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B80_u8981_u4ECB_u7ECD"><a href="#u7B80_u8981_u4ECB_u7ECD" class="headerlink" title="简要介绍"></a>简要介绍</h1><p>在Matplotlib官网上看到的介绍如下：</p>
<blockquote>
<p>matplotlib is a python 2D plotting library which produces publication quality figures in a variety of hardcopy formats and interactive environments across platforms. matplotlib can be used in python scripts, the python and ipython shell (ala MATLAB®* or Mathematica®†), web application servers, and six graphical user interface toolkits</p>
</blockquote>
<p>我们可以看到用这个工具可以绘制出质量很高的图例：<br><img src="http://matplotlib.org/_static/logo_sidebar_horiz.png" alt="figure1"></p>
<h1 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h1><p>在MAC下的安装很简单：</p>
<blockquote>
<p>$ pip install matplotlib</p>
</blockquote>
<p>安装成功后，可以在matplotlib上找一些例子试试看，比如：</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation


def data_gen(t=0):
    cnt = 0
    while cnt &lt; 1000:
        cnt += 1
        t += 0.1
        yield t, np.sin(2*np.pi*t) * np.exp(-t/10.)


def init():
    ax.set_ylim(-1.1, 1.1)
    ax.set_xlim(0, 10)
    del xdata[:]
    del ydata[:]
    line.set_data(xdata, ydata)
    return line,

fig, ax = plt.subplots()
line, = ax.plot([], [], lw=2)
ax.grid()
xdata, ydata = [], []


def run(data):
    # update the data
    t, y = data
    xdata.append(t)
    ydata.append(y)
    xmin, xmax = ax.get_xlim()

    if t &gt;= xmax:
        ax.set_xlim(xmin, 2*xmax)
        ax.figure.canvas.draw()
    line.set_data(xdata, ydata)

    return line,

ani = animation.FuncAnimation(fig, run, data_gen, blit=False, interval=10,
                              repeat=False, init_func=init)
plt.show()
</code></pre><p>然后运行一下，就可以看到这样的图样, nice~<br><img src="http://img0.ph.126.net/TDyKUq50DtiTQEEP0vjQrA==/6631352539215188664.png" alt="figure_01"></p>
<p>另外，在官网上也可以找到大量的<a href="http://matplotlib.org/examples/index.html" target="_blank" rel="external">例子和说明文档</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B80_u8981_u4ECB_u7ECD"><a href="#u7B80_u8981_u4ECB_u7ECD" class="headerlink" title="简要介绍"></a>简要介绍</h1><p>在Matplotlib官网上看到的介绍如下：</]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习实战-学习笔记02]]></title>
    <link href="http://leeobarloon.github.io/2016/01/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
    <id>http://leeobarloon.github.io/2016/01/24/机器学习实战-学习笔记02/</id>
    <published>2016-01-24T03:09:51.000Z</published>
    <updated>2016-01-24T13:47:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u673A_u5668_u5B66_u4E60__u8BFB_u4E66_u7B14_u8BB002"><a href="#u673A_u5668_u5B66_u4E60__u8BFB_u4E66_u7B14_u8BB002" class="headerlink" title="机器学习 读书笔记02"></a>机器学习 读书笔记02</h2><p>我们一起来学习机器学习中的第一个算法：</p>
<h3 id="k-_u8FD1_u90BB_u7B97_u6CD5_28k-Nearest_Neighbour_u7B97_u6CD5_uFF0CKNN_u7B97_u6CD5_uFF09"><a href="#k-_u8FD1_u90BB_u7B97_u6CD5_28k-Nearest_Neighbour_u7B97_u6CD5_uFF0CKNN_u7B97_u6CD5_uFF09" class="headerlink" title="k-近邻算法(k-Nearest Neighbour算法，KNN算法）"></a>k-近邻算法(k-Nearest Neighbour算法，KNN算法）</h3><p>什么是k-近邻算法呢？<br>书中的定义比较简单：</p>
<blockquote>
<p>采用测量不同特征值之间的距离方法进行分类的算法</p>
</blockquote>
<p>而百度百科上的解释更全面一点</p>
<blockquote>
<p>K最近邻(k-Nearest Neighbour，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。</p>
<p>用官方的话来说，所谓K近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例（也就是上面所说的K个邻居）， 这K个实例的多数属于某个类，就把该输入实例分类到这个类中。</p>
</blockquote>
<p>KNN算法的优点和缺点也比较明显：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>算法优点</td>
<td>精度高，对异常值不明感，无数据输入假定</td>
<td></td>
</tr>
<tr>
<td>缺点</td>
<td>计算复杂度高、空间复杂度高</td>
<td></td>
</tr>
<tr>
<td>使用数据范围</td>
<td>数值型和标称型</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="KNN_u7B97_u6CD5_u7684_u4F2A_u4EE3_u7801_uFF1A"><a href="#KNN_u7B97_u6CD5_u7684_u4F2A_u4EE3_u7801_uFF1A" class="headerlink" title="KNN算法的伪代码："></a>KNN算法的伪代码：</h3><ol>
<li>计算已知类别数据节中的点与当前点之间的距离</li>
<li>按照距离递增顺序排序</li>
<li>选取与当前点距离最小的k个点</li>
<li>确定前k个点所在类别的出现频率</li>
<li>返回前k个点出现频率最高的类别最为当前点的预测分类</li>
</ol>
<hr>
<h3 id="kNN_u7B97_u6CD5_u7684python_u4EE3_u7801_uFF1A"><a href="#kNN_u7B97_u6CD5_u7684python_u4EE3_u7801_uFF1A" class="headerlink" title="kNN算法的python代码："></a>kNN算法的python代码：</h3><pre><code>from numpy import *
import operator

&apos;&apos;&apos;
获得已有的数据集和标签
&apos;&apos;&apos;
def createDataSet():
    group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]])
    labels = [&apos;A&apos;, &apos;A&apos;, &apos;B&apos;, &apos;B&apos;]
    return group, labels

&apos;&apos;&apos;
分类算法0，获得输入的inX最应该属于的标签类型
&apos;&apos;&apos;
def classify0(inX, dataSet, labels, k):
    #计算距离
    dataSetSize = dataSet.shape[0]
    diffMat = tile(inX, (dataSetSize,1)) - dataSet
    sqDiffMat = diffMat**2
    sqDistances = sqDiffMat.sum(axis=1)
    distances = sqDistances**0.5
    sortedDistIndicies = distances.argsort()

    classCount = {}
    #选择距离最小的k个点
    for i in range(k):
        voteIlabel = labels[sortedDistIndicies[i]]
        classCount[voteIlabel] = classCount.get(voteIlabel,0)+1
    #排序    
    sortedDistIndicies = sorted(classCount.iteritems(),
                                key=operator.itemgetter(1), reverse=True)
    return sortedDistIndicies[0][0]

if __name__ == &apos;__main__&apos;:
    group, labels = createDataSet()
    label = classify0([0,0], group, labels, 3)
    print label
</code></pre><p>获得的结果是：</p>
<pre><code>$ B
</code></pre><p>在上述的代码中，会涉及到一些有关python中numpy类库的使用，请不熟悉的朋友查看相关代码或文档，当然，debug来单步调试上述代码，也是一个很好的方法，其实就是利用了欧氏距离来算了两个向量点之间的距离，然后选取了其中最短的一个，并获得了其对应的类型。</p>
<p>说明输入的测试数据[0,0]更应该属于B类数据</p>
<p>上面是我们写的第一个分类算法，但我们要知道，分类器并不一定总是正确的，我们可以通过多种方法检测分类算法的正确性。<br>我们可以通过大量的测试，来计算出分类算法的错误率，错误率是评估分类器是否有效的方法之一;</p>
<h3 id="u7B2C_u4E8C_u4E2A_u4F8B_u5B50_uFF0C_u7EA6_u4F1A_u6570_u636E_u5206_u7C7B"><a href="#u7B2C_u4E8C_u4E2A_u4F8B_u5B50_uFF0C_u7EA6_u4F1A_u6570_u636E_u5206_u7C7B" class="headerlink" title="第二个例子，约会数据分类"></a>第二个例子，约会数据分类</h3><p>在开始学习书中提到的第二个例子前，我们先要了解一下它中间要用到的一个工具：<br><a href="http://www.labri.fr/perso/nrougier/teaching/matplotlib/" target="_blank" rel="external">matplotlib</a></p>
<p>其安装和使用的简要说明请参见此<a href="http://leeobarloon.github.io/2016/01/24/Matplotlib%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E/">文章</a></p>
<p>另外，这个例子中会用到一个样本文件，朋友们可以从这里<a href="http://download.csdn.net/detail/mctyro/6504521" target="_blank" rel="external">下载</a>,如果找不到，自行google或者baidu吧~</p>
<p>我们可以打开ch02中的<code>datingTestSet.txt</code>文档，可以发现类似这样的数据；</p>
<pre><code>40920    8.326976    0.953952    largeDoses
14488    7.153469    1.673904    smallDoses
26052    1.441871    0.805124    didntLike
75136    13.147394    0.428964    didntLike
38344    1.669788    0.134296    didntLike
72993    10.141740    1.032955    didntLike
35948    6.830792    1.213192    largeDoses
42666    13.276369    0.543880    largeDoses
67497    8.631577    0.749278    didntLike
...
</code></pre><p>神马意思呢？</p>
<p>颤抖吧，据说这是某个约会达人专门为她（注意，是她！）自己约会的对象所整理出来的一个数据样本，其中对应的特征分别是：</p>
<pre><code>* 每年获得的飞行常客里程数
* 玩视频游戏所耗时间百分比
* 每周消费的冰激凌公升数（什么鬼...)
</code></pre><p>最后一行的含义则表示该样本所属的类型：</p>
<pre><code>不喜欢的人（didntLike），
魅力一般的人（smallDoses），
极具魅力的人（largeDoses）
</code></pre><p>那么，有了这个样本类型后，该女子在下一次遇到一个新的约会对象的时候，就会通过一个算法，来预测该名男子是不是一个有魅力的人…当然，她问的问题可能会让此男摸不着头脑:”哎，你这一年飞行了多少公里啊？”,”一周你吃几次冰激凌，什么包装的？”以及”你玩不玩游戏，玩多久”之类的问题，如果遇到问这种问题的女人，请自行退散…！</p>
<p>…言归正传(写这本书的作者脑洞挺大）</p>
<p>我们看这个程序是怎嘛写滴：</p>
<pre><code>def file2matrix(filename):
fr = open(filename)
arrayOfLines = fr.readlines()
numberOfLines = len(arrayOfLines)
returnMat = zeros((numberOfLines, 3))
classLabelVector = []
index = 0
for line in arrayOfLines:
    line = line.strip()
    listFromLine = line.split(&apos;\t&apos;)
    returnMat[index, :] = listFromLine[0:3]
    classLabelVector.append(int(listFromLine[-1]))
    index+=1
return returnMat, classLabelVector

if __name__ == &apos;__main__&apos;:
    returnMat, classLabelVector = file2matrix(&apos;datingTestSet2.txt&apos;);
</code></pre><p>程序很简单，其实就是将文件中的内容，格式化的导入到内存的结构化数据中，其中zeros((x,y))的含义就是构造一个x行，y列的矩阵，每个向量用0.0填充，当然，在python中，是用二维数组表示的，比如：</p>
<pre><code>&gt;&gt;&gt; zeros((4,3))
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.],
       [ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])    
</code></pre><p>那么，接下来，我们获得了一个1000行，3列的数据结构，然后也有了这1000行数据分别代表是否是理想的约会对象的标示，接下来的任务就是利用matplotlib来绘制图像了<br>运行下面的代码：</p>
<pre><code>def draw_figure01():
    returnMat, classLabelVector = file2matrix(&apos;datingTestSet2.txt&apos;);
    fig = plt.figure()
    ax = fig.add_subplot(111)

    # 绘制返回结果中的第1和第2列数据,分别代表:玩游戏时间和冰激凌公升数
    ax.scatter(returnMat[:, 1], returnMat[:, 2])
    plt.show()


if __name__ == &apos;__main__&apos;:
    &apos;&apos;&apos;
    group, labels = createDataSet()
    label = classify0([0,0], group, labels, 3)
    print label

    &apos;&apos;&apos;
    draw_figure01()
</code></pre><p>获得的效果如下图：        </p>
<p><img src="http://img2.ph.126.net/37xd9_uaFcEVkvJ1RWN1fA==/6631419609424482845.jpg" alt="figure_02"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u673A_u5668_u5B66_u4E60__u8BFB_u4E66_u7B14_u8BB002"><a href="#u673A_u5668_u5B66_u4E60__u8BFB_u4E66_u7B14_u8BB002" class="headerlink"]]>
    </summary>
    
      <category term="机器学习" scheme="http://leeobarloon.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="读书笔记" scheme="http://leeobarloon.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[github上的ios代码]]></title>
    <link href="http://leeobarloon.github.io/2016/01/23/IOS%20Development/"/>
    <id>http://leeobarloon.github.io/2016/01/23/IOS Development/</id>
    <published>2016-01-23T15:08:13.000Z</published>
    <updated>2016-01-23T15:08:13.000Z</updated>
    <content type="html"><![CDATA[<p>现在的IOS开发，有很多可以借鉴的轮子，我们不用再像之前一样，自己还需要写很多比较高级一些的控件，目前在很多的社区，已经有大量的高级控件以及可以借鉴的代码；对于产品初期，快速搭建一个demo效果的APP应用来说，最好的方法就是从其中挑选比较适合你么产品的开源代码，加以借鉴和使用<br><a id="more"></a></p>
<p>在我们目前的产品开发中，分别使用了如下几个开源控件和框架</p>
<ol>
<li><p>AFNetworking<br> 负责HTTP通讯，用户可以很方便的基于自己的协议，实现一套通讯框架</p>
</li>
<li><p>FMDB<br> SQLite数据库框架</p>
</li>
<li><p>PXAlertview<br> 对话框</p>
</li>
<li><p>MBProgressHUD<br> 进度显示框</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在的IOS开发，有很多可以借鉴的轮子，我们不用再像之前一样，自己还需要写很多比较高级一些的控件，目前在很多的社区，已经有大量的高级控件以及可以借鉴的代码；对于产品初期，快速搭建一个demo效果的APP应用来说，最好的方法就是从其中挑选比较适合你么产品的开源代码，加以借鉴和使用<br>]]>
    
    </summary>
    
      <category term="Github" scheme="http://leeobarloon.github.io/tags/Github/"/>
    
      <category term="IOS" scheme="http://leeobarloon.github.io/tags/IOS/"/>
    
      <category term="IOS代码库" scheme="http://leeobarloon.github.io/categories/IOS%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习实战-学习笔记01]]></title>
    <link href="http://leeobarloon.github.io/2016/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <id>http://leeobarloon.github.io/2016/01/23/机器学习实战-学习笔记01/</id>
    <published>2016-01-23T13:54:01.000Z</published>
    <updated>2016-01-24T07:05:38.000Z</updated>
    <content type="html"><![CDATA[<p>##机器学习 读书笔记01<br>最近开始研究机器学习(Computer Learning）,发现其实已经有很多很好的资源了，其中比较著名的就是网易云课堂上的<a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">斯坦福大学公开课 ：机器学习课程</a>，公开课的老师是一个华人，最后一查，发现他是一个大牛，哦不，是巨牛，请看他的相关介绍：<a href="http://baike.baidu.com/link?url=82UgpsKu2N8pN-9XWsJLQkeGVArb5GRdDthrAjGfwtuHEXNhWcTA7PQI9eZGGmxz9sogbViWV0annPGr0XGOMrF7Via3PdjXliQo0_umzuz6Q9EWE-g6y5NN1L_gdX1zlpV17EsqVchsQ9AlPw61w_" target="_blank" rel="external">Andrew Ng</a>，后来发现他是著名的公开课网站<a href="https://www.coursera.org/" target="_blank" rel="external">Course</a>的co-fonder，然后在这个网站上也发现了有关机器学习的课程<a href="https://www.coursera.org/learn/machine-learning/" target="_blank" rel="external">公开课</a></p>
<p>网上有学习过他的课程的网友说，网易云课堂上的课程比较老了，还是Coursera上的比较新，所以我就抱着试一试看的态度，报了他的公开课，刚好过两天就要开一期了，但愿我可以按时完成。</p>
<p>首先来看一下有关机器学习的一些概念，我在另外一篇blog里头已经整理过了，请刚兴趣的同学移步<a href="http://leeobarloon.github.io/2016/01/23/ComputerLearningConcept/">此处</a></p>
<p>后来，回家本来想翻看一下之前大学时候数学相关的书籍，然后竟然被我找到了这本书<a href="http://book.douban.com/subject/24703171/" target="_blank" rel="external">《机器学习实战》</a>，原来我去年就买过这本书，但后来发现看不大懂，看来上帝早有安排啊，哈哈~</p>
<hr>
<p>言归正传，下面我们就开始学习这本书吧~</p>
<p>在书的第一章，作者提到了机器学习常常会提到的两个概念，或者说是种类：</p>
<pre><code>1. 监督学习
2. 非监督学习
</code></pre><p>所谓监督学习，大概的意思就是这类算法知道预测什么，即目标变量的分类信息；<br>而非监督学习，则表示数据没有分类信息，也没有目标值，需要机器通过学习自己去聚合整理出有规律的信息；</p>
<p>这张表会比较好的表达出上述两种机器学习所涉及到的算法</p>
<table>
<thead>
<tr>
<th>监督学习的用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>k-近邻算法</td>
<td></td>
</tr>
<tr>
<td>线性回归</td>
<td></td>
</tr>
<tr>
<td>朴素贝叶斯算法</td>
<td></td>
</tr>
<tr>
<td>局部加权线性回归</td>
<td></td>
</tr>
<tr>
<td>支持向量机</td>
<td></td>
</tr>
<tr>
<td>Ridge回归</td>
<td></td>
</tr>
<tr>
<td>决策树</td>
<td></td>
</tr>
<tr>
<td>Lasso最小回归系数估计</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>非监督学习的用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>k-均值</td>
<td></td>
</tr>
<tr>
<td>最大期望算法</td>
<td></td>
</tr>
<tr>
<td>KBSCAN</td>
<td></td>
</tr>
<tr>
<td>Parzen窗设计</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果看不懂，不要着急，因为我也看不懂 😢</p>
<h2 id="u5982_u4F55_u9009_u62E9_u7B97_u6CD5"><a href="#u5982_u4F55_u9009_u62E9_u7B97_u6CD5" class="headerlink" title="如何选择算法"></a>如何选择算法</h2><p>那么，面对所要解决的问题，我们如何选择合适的算法呢？</p>
<p>首先，我么要考虑算法的目的，然后根据目的选择对应的算法，下图只能说是一个大概，具体的策略还需要进一步学习</p>
<p><img src="http://img2.ph.126.net/nT1jFeB01R7PJiGoD4BFrg==/6631445997703530932.jpg" alt="flow-image"></p>
<p>其次，我们要考虑数据，对数据了解的越充分，越容易做出正确的算法决策，主要考虑下面几个方面；</p>
<ol>
<li>特征值是离散型变量还是连续型变量</li>
<li>特征值中是否有缺失的值</li>
<li>何种原因造成缺失</li>
<li>数据中是否存在异常值</li>
<li>某个值发生的频率如何</li>
<li>…</li>
</ol>
<h2 id="u673A_u5668_u5B66_u4E60_u5F00_u53D1_u6B65_u9AA4"><a href="#u673A_u5668_u5B66_u4E60_u5F00_u53D1_u6B65_u9AA4" class="headerlink" title="机器学习开发步骤"></a>机器学习开发步骤</h2><p>同其他的开发步骤差不多，机器学习也有如下几个步骤：</p>
<ol>
<li>收集数据</li>
<li>准备输入数据</li>
<li>分析输入数据</li>
<li>训练算法</li>
<li>测试算法</li>
<li>使用算法</li>
</ol>
<p>其中，第4和第5步骤，是机器学习的核心</p>
<p>本书主要用到的语言是<code>python</code>，并且会频繁的用到<code>python</code>中的<code>Numpy</code>类库</p>
<p>具体如何使用，请大家自行查考资料，这里就不在啰嗦了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>##机器学习 读书笔记01<br>最近开始研究机器学习(Computer Learning）,发现其实已经有很多很好的资源了，其中比较著名的就是网易云课堂上的<a href="http://open.163.com/special/opencourse/machinelea]]>
    </summary>
    
      <category term="机器学习" scheme="http://leeobarloon.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="读书笔记" scheme="http://leeobarloon.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Computer Learning Concept]]></title>
    <link href="http://leeobarloon.github.io/2016/01/23/ComputerLearningConcept/"/>
    <id>http://leeobarloon.github.io/2016/01/23/ComputerLearningConcept/</id>
    <published>2016-01-23T08:56:02.000Z</published>
    <updated>2016-01-23T08:56:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u673A_u5668_u5B66_u4E60"><a href="#u673A_u5668_u5B66_u4E60" class="headerlink" title="机器学习"></a>机器学习</h1><p>机器学习的概念：<br>关于机器学习的概念有很多，我们可以从下面基本书中的定义中自己领会</p>
<h2 id="Tom_Mitchell_u2018s_Machine_Learning"><a href="#Tom_Mitchell_u2018s_Machine_Learning" class="headerlink" title="Tom Mitchell‘s Machine Learning"></a>Tom Mitchell‘s Machine Learning</h2><p>Tom Mitchell在他的《<a href="http://www.amazon.com/dp/0070428077?tag=job0ae-20" target="_blank" rel="external">Machine Learning</a>》（中文版<a href="http://www.amazon.cn/gp/product/B002WC7NH2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=536&amp;creative=3200&amp;creativeASIN=B002WC7NH2&amp;linkCode=as2&amp;tag=vastwork-23" target="_blank" rel="external">机器学习</a>)中如此定义：</p>
<blockquote>
<p>The field of machine learning is concerned with the question of how to construct computer programs that automatically improve with experience.</p>
</blockquote>
<p>Tom Mitchell还有一个更加常被别人提到的定义：</p>
<blockquote>
<p>A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E</p>
</blockquote>
<p>这个概念比较绕口，翻译成中文就是：</p>
<blockquote>
<p>所谓机器学习，就是给定一个任务T和一个测量方法P，可以获得的经验E，如果针对该任务T，其针对P的测量结果性能可以得到提升，则说明其得到了学习</p>
</blockquote>
<p>##Elements of Statistical Learning<br>在《<a href="http://www.amazon.com/dp/0387848576?tag=inspiredalgor-20" target="_blank" rel="external">The Elements of Statistical Learning: Data Mining, Inference, and Prediction</a>》中如此定义：</p>
<blockquote>
<p>Vast amounts of data are being generated in many fields, and the statisticians’s job is to make sense of it all: to extract important patterns and trends, and to understand “what the data says”. We call this learning from data.</p>
</blockquote>
<p>翻译成中文:</p>
<blockquote>
<p>在很多领域都会产生海量的数据，统计学家的工作就是让这些数据产生意义（或者说从中提取出有意义的含义）：提取重要的模式与趋势，然后弄明白“这些数据到底在说什么”.我们称之为：learning from data</p>
</blockquote>
<h2 id="Pattern_Recognition"><a href="#Pattern_Recognition" class="headerlink" title="Pattern Recognition"></a>Pattern Recognition</h2><p>Bishop在他的书《<a href="http://www.amazon.com/dp/0387310738?tag=inspiredalgor-20" target="_blank" rel="external">Pattern Recognition and Machine Learning</a>》的定义：</p>
<blockquote>
<p>One of the most interesting features of machine learning is that it lies on the boundary of several different academic disciplines, principally computer science, statistics, mathematics, and engineering. …machine learning is usually studied as part of artificial intelligence, which puts it firmly into computer science …understanding why these algorithms work requires a certain amount of statistical and mathematical sophistication that is often missing from computer science undergraduates.</p>
</blockquote>
<p>这么长的英文，不翻译成中文对不起观众…</p>
<blockquote>
<p>机器学习最有趣的地方就是：它基于几种不同学科，主要包括：计算机科学，统计学，数学，工程学等等，机器学习常用在人工智能领域（这也应该包括在计算机科学中）。要弄明白这些问题，常常需要一些统计学和数学的理论，而这些恰恰是那些从计算机科学专业别也得学生所常常遗忘掉的…</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u673A_u5668_u5B66_u4E60"><a href="#u673A_u5668_u5B66_u4E60" class="headerlink" title="机器学习"></a>机器学习</h1><p>机器学习的概念：<br>关于机器学习的概念有很多]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[CreateHexo]]></title>
    <link href="http://leeobarloon.github.io/2016/01/22/CreateHexo/"/>
    <id>http://leeobarloon.github.io/2016/01/22/CreateHexo/</id>
    <published>2016-01-22T03:18:01.000Z</published>
    <updated>2016-01-22T03:18:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="HEXO__u521B_u5EFABlog"><a href="#HEXO__u521B_u5EFABlog" class="headerlink" title="HEXO 创建Blog"></a>HEXO 创建Blog</h1><p>决定又重新开始写blog，以前用jekyll，但这次想换成hexo，它是基于node.js的blog模板框架</p>
<p>##HEXO介绍<br><a href="https://hexo.io/zh-cn/" target="_blank" rel="external">hexo</a>是一个目前比较流行的博客框架<br>主要有如下几个优点：</p>
<ul>
<li>生成快速</li>
<li>支持 Markdown</li>
<li>一键部署</li>
<li>插件丰富</li>
</ul>
<p>##安装前提<br>安装HEXO前，必须保证您的机器上已经有：<br><a href="http://git-scm.com/" target="_blank" rel="external">git</a><br><a href="https://nodejs.org/en/" target="_blank" rel="external">node.js</a></p>
<h2 id="u5B89_u88C5Hexo_u4E0E_u5EFA_u7AD9"><a href="#u5B89_u88C5Hexo_u4E0E_u5EFA_u7AD9" class="headerlink" title="安装Hexo与建站"></a>安装Hexo与建站</h2><h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &#60;fold&#62;&#10;$ cd &#60;fold&#62;&#10;$ npm install</span><br></pre></td></tr></table></figure>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server&#10;or&#10;$ hexo s</span><br></pre></td></tr></table></figure>
<p>就可以看到如下结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>说明启动成功</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="HEXO__u521B_u5EFABlog"><a href="#HEXO__u521B_u5EFABlog" class="headerlink" title="HEXO 创建Blog"></a>HEXO 创建Blog</h1><p>决定又重新开始写blog，以]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[first hexo]]></title>
    <link href="http://leeobarloon.github.io/2016/01/20/first-hexo/"/>
    <id>http://leeobarloon.github.io/2016/01/20/first-hexo/</id>
    <published>2016-01-20T07:58:55.000Z</published>
    <updated>2016-01-20T11:26:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="This_is_a_test_Blog"><a href="#This_is_a_test_Blog" class="headerlink" title="This is a test Blog"></a>This is a test Blog</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="This_is_a_test_Blog"><a href="#This_is_a_test_Blog" class="headerlink" title="This is a test Blog"></a>This is a test Blog</h2>]]>
    </summary>
    
      <category term="hexo" scheme="http://leeobarloon.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://leeobarloon.github.io/2016/01/20/hello-world/"/>
    <id>http://leeobarloon.github.io/2016/01/20/hello-world/</id>
    <published>2016-01-20T07:48:33.000Z</published>
    <updated>2016-01-20T07:48:33.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用纯代码构建IOS项目-01]]></title>
    <link href="http://leeobarloon.github.io/2015/03/30/CreateIOSViaPureCode/"/>
    <id>http://leeobarloon.github.io/2015/03/30/CreateIOSViaPureCode/</id>
    <published>2015-03-29T16:00:00.000Z</published>
    <updated>2016-01-23T15:06:52.000Z</updated>
    <content type="html"><![CDATA[<p>辗转反侧之后，还是决定用纯代码的方式来构建IOS的项目了，至少这种方式我本人还是比较习惯的，虽然我更习惯用所见即所得的nib或者stroyboard的方式来构建，但是我个人觉得stroyboard的方式有一些令人难以理解，并且对项目未来的可维护性方面，还是劣于纯代码开发的方式，那还是笨鸟先飞，就用敲代码的方式来写IOS客户端吧~</p>
<a id="more"></a>
<ol>
<li><p>选择File-&gt;New Project-&gt;Single View Application,填写必要信息，创建一个工程</p>
</li>
<li><p>打开Supporting Files-&gt;info.plist<br>删掉有关StoryBoard的配置</p>
</li>
<li><p>删掉Main.storyboard</p>
</li>
</ol>
<p>修改AppDelegate.m 中的方法：</p>
<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:    (NSDictionary *)launchOptions 
{
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

    UIView *myView = [[UIView alloc] initWithFrame:CGRectMake(10/* x */, 10/* y */, 200/* width */, 200/* height */)];

    myView.backgroundColor = [UIColor redColor];

    [self.window addSubview:myView];
    [myView setFrame:CGRectMake(10, 30, 200, 200)];
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];
    return YES;
}
</code></pre><p>然后运行，就可以看到一个由纯代码运行成功的ios的简单例子了…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>辗转反侧之后，还是决定用纯代码的方式来构建IOS的项目了，至少这种方式我本人还是比较习惯的，虽然我更习惯用所见即所得的nib或者stroyboard的方式来构建，但是我个人觉得stroyboard的方式有一些令人难以理解，并且对项目未来的可维护性方面，还是劣于纯代码开发的方式，那还是笨鸟先飞，就用敲代码的方式来写IOS客户端吧~</p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://leeobarloon.github.io/tags/IOS/"/>
    
      <category term="Objc" scheme="http://leeobarloon.github.io/tags/Objc/"/>
    
      <category term="IOS开发" scheme="http://leeobarloon.github.io/categories/IOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[github上的ios代码]]></title>
    <link href="http://leeobarloon.github.io/2015/03/30/IOS%20Github%20Repos/"/>
    <id>http://leeobarloon.github.io/2015/03/30/IOS Github Repos/</id>
    <published>2015-03-29T16:00:00.000Z</published>
    <updated>2016-01-23T15:07:36.000Z</updated>
    <content type="html"><![CDATA[<p>请看链接：<a href="http://github.ibireme.com/github/list/ios/" target="_blank" rel="external">IOS Github Repos</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>请看链接：<a href="http://github.ibireme.com/github/list/ios/" target="_blank" rel="external">IOS Github Repos</a></p>
]]>
    </summary>
    
      <category term="Github" scheme="http://leeobarloon.github.io/tags/Github/"/>
    
      <category term="IOS" scheme="http://leeobarloon.github.io/tags/IOS/"/>
    
      <category term="IOS代码库" scheme="http://leeobarloon.github.io/categories/IOS%E4%BB%A3%E7%A0%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用纯代码构建IOS项目-02]]></title>
    <link href="http://leeobarloon.github.io/2015/03/30/CreateIOSViaPureCode02/"/>
    <id>http://leeobarloon.github.io/2015/03/30/CreateIOSViaPureCode02/</id>
    <published>2015-03-29T16:00:00.000Z</published>
    <updated>2016-01-23T15:07:08.000Z</updated>
    <content type="html"><![CDATA[<p>目前IOS APP中最常见的应该就是基于Web的应用，而IOS中web框架也是相当多，目前非常流行的一个就是<a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>，本文就先介绍一下，如何在IOS上文所说的纯代码的开发环境中，加入AFNetworking库</p>
<a id="more"></a>
<p>下文就是AFNetworking在自己的github上的介绍：</p>
<blockquote>
<p>AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the Foundation URL Loading System, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.</p>
</blockquote>
<p>下面，我们就来试着使用以下这个大名鼎鼎的框架吧~</p>
<p>首先安装<a href="http://cocoapods.org/" target="_blank" rel="external">CocoaPods</a>，CoCoaPods是一个Obj-c的依赖管理工具，就类似于Maven之与Java一样。<br>我们可以通过命令行来安装：</p>
<pre><code>$ sudo gem install cocoapods
$ pod setup 
</code></pre><p>然后，移动到我们的项目目录，然后输入如下命令：</p>
<pre><code>$ touch Podfile
$ open -a Xcode Podfile
</code></pre><p>上述两个命令的功能就是，先创建了一个Podfile文件，然后用xcode打开了，下面，我们就在podfile中添加一些内容：</p>
<pre><code>source &apos;https://github.com/CocoaPods/Specs.git&apos;
platform :ios, &apos;7.0&apos;
pod &apos;AFNetworking&apos;, &apos;~&gt; 2.5&apos;
</code></pre><p>跟AFNetworking相关的依赖信息就写好了，下面我们就来安装上述依赖库：</p>
<pre><code>$ pod install
</code></pre><p>如果上述安装很慢的话，可以考虑下述命令，因为有可能pod会更新一下gem库，你知道，伟大的墙会搞死你</p>
<pre><code>$ pod install --no-repo-update
</code></pre><p>注意，以后就要用xcworkspace来打开项目了！</p>
<pre><code>$ open &lt;your Application name&gt;.xcworkspace
</code></pre><p>好了，接下来就可以使用NFNetworking了~，只需要在用到的地方<code>include</code>需要的库即可~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>目前IOS APP中最常见的应该就是基于Web的应用，而IOS中web框架也是相当多，目前非常流行的一个就是<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>，本文就先介绍一下，如何在IOS上文所说的纯代码的开发环境中，加入AFNetworking库</p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://leeobarloon.github.io/tags/IOS/"/>
    
      <category term="Objc" scheme="http://leeobarloon.github.io/tags/Objc/"/>
    
      <category term="IOS开发" scheme="http://leeobarloon.github.io/categories/IOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift first try - Swift 初探]]></title>
    <link href="http://leeobarloon.github.io/2015/03/27/Swift%20First%20Try/"/>
    <id>http://leeobarloon.github.io/2015/03/27/Swift First Try/</id>
    <published>2015-03-26T16:00:00.000Z</published>
    <updated>2016-01-23T15:06:36.000Z</updated>
    <content type="html"><![CDATA[<p>自己也算写过几个IOS程序，但是一直以来都不是很喜欢写IOS的代码，因为objective-c的语法太TMD的恶心了，特别是它那丑陋的[]的语法，尽管很多人都说习惯了就好，还是很优美的，但我压根不觉得，另外，obj-c的内存控制，本来已经习惯了，后来它自己又加上了ARC，我就更不知所谓了，而且Xcode每次更新后，其中很多特性就需要继续学习，或者说重新学习，干脆我就重新学Swift得了，但愿这玩意儿优美一点…</p>
<a id="more"></a>
<p>初看，swift和一些脚本语言有点类似，也可以不用明确的声明变量的类型，比如你可以这样:</p>
<pre><code>var testString = &quot;a string&quot;
</code></pre><p>也可以这样</p>
<pre><code>var testInt = 10
</code></pre><p>当然，你也可以明确的申明变量的类型：</p>
<pre><code>var testDouble : Double = 10.32
</code></pre><p>swift有很多类型，其实也无非就是<code>Int</code>,<code>Float</code>,<code>Double</code>,<code>String</code>,<code>Bool</code>等，要注意的是，当你这样申明一个变量的时候：<code>var test = 1230.3</code>,编译器会自动的认为这是一个Double</p>
<p>另外，Swift也可以申明常量：</p>
<pre><code>let constantValue = 10
</code></pre><p>并且，还建议开发者应该优先使用<code>let</code>而不是<code>var</code>,因为这样，编译器可以做一些优化，那咱就<code>let it go</code>吧。</p>
<p>在Swift中还有这样的写法：</p>
<pre><code>let testName = “ComiCoder”
let testStr = “\(testName) is a good man!”
println(testStr) 

-----output----
ComiCoder is a good man!
</code></pre><p>你会发现，我们可以用: <code>\(your expression)</code> 这样的语法来在字符串中内嵌其他变量</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自己也算写过几个IOS程序，但是一直以来都不是很喜欢写IOS的代码，因为objective-c的语法太TMD的恶心了，特别是它那丑陋的[]的语法，尽管很多人都说习惯了就好，还是很优美的，但我压根不觉得，另外，obj-c的内存控制，本来已经习惯了，后来它自己又加上了ARC，我就更不知所谓了，而且Xcode每次更新后，其中很多特性就需要继续学习，或者说重新学习，干脆我就重新学Swift得了，但愿这玩意儿优美一点…</p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://leeobarloon.github.io/tags/IOS/"/>
    
      <category term="SWIFT" scheme="http://leeobarloon.github.io/tags/SWIFT/"/>
    
      <category term="Swift入门" scheme="http://leeobarloon.github.io/categories/Swift%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift first try - Swift 的class]]></title>
    <link href="http://leeobarloon.github.io/2015/03/27/Swift%20First%20Try%2002/"/>
    <id>http://leeobarloon.github.io/2015/03/27/Swift First Try 02/</id>
    <published>2015-03-26T16:00:00.000Z</published>
    <updated>2016-01-23T15:06:21.000Z</updated>
    <content type="html"><![CDATA[<p>下面我们来看看swift中，如何定义和使用一个类<br><a id="more"></a></p>
<p>其实很简单：</p>
<pre><code>class MyTestClass {

}
</code></pre><p>这样子，一个名字为 <code>MyTestClass</code> 的类就被定义出来了</p>
<p>下面，我们可以在这个类中添加一个构造方法，并且在构造方法中传入两个参数first和second</p>
<pre><code>class MyTestClass {
    init(first:Int, second:Double){
    }
}
</code></pre><p>然后我们可以给这个类添加3个成员变量elem01，elem02和elem03，并且在构造方法中加入赋值的功能，你可以看到，构造方法就是以<code>init()</code>命名的方法，</p>
<pre><code>class MyTestClass {

    var elem01:Double
    var elem02:Double
    var elem03:Double
    init(first: Double, second: Double){
        elem01 = first
        elem02 = second
        elem03 = first / second
    }
}
</code></pre><p>然后，我们可以在这个类中再添加一些成员方法，我们发现，首先，方法是以<code>func</code>开头的，另外，第一个方法<code>getElemDescription</code>没有返回值，而第二个方法有返回值，它用<code>-&gt;Double</code>表示其返回一个Double值。（<em>下面的代码，请放到上面那个类的大括号中间</em>）</p>
<pre><code>func getElemDescription(){

    println( &quot;Elem01=\(elem01) Elem02=\(elem02) Elem03=\(elem03)&quot;)

}

func getElem03()-&gt; Double{
    return elem03
}
</code></pre><p>这样，我们就可以使用这个类了，我们先创建一个对象，然后调用它的两个方法：</p>
<pre><code>let testObj = MyTestClass(first: 10.2, second: 123.2)

testObj.getElemDescription()
testObj.getElem03()
</code></pre><p>这样，我们就初步了解了Swift类的一个创建和对象的使用情况~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面我们来看看swift中，如何定义和使用一个类<br>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://leeobarloon.github.io/tags/IOS/"/>
    
      <category term="SWIFT" scheme="http://leeobarloon.github.io/tags/SWIFT/"/>
    
      <category term="Swift入门" scheme="http://leeobarloon.github.io/categories/Swift%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git step by step 5 - git的工作流]]></title>
    <link href="http://leeobarloon.github.io/2015/03/23/git%20step%20by%20step%2005/"/>
    <id>http://leeobarloon.github.io/2015/03/23/git step by step 05/</id>
    <published>2015-03-22T16:00:00.000Z</published>
    <updated>2016-01-23T13:49:13.000Z</updated>
    <content type="html"><![CDATA[<p>接上文：<a href="http://comicoder.github.io/git%20step%20by%20step/2015/03/19/git%20step%20by%20step%2004/" target="_blank" rel="external">git step by step4</a></p>
<a id="more"></a>
<p>git的工作主要分布在三个部分</p>
<p><img src="http://7xi7tu.com1.z0.glb.clouddn.com/cc0001.png?imageView2/2/w/203/h/203&amp;e=1427166456&amp;token=ejngiHmFYkCZWtp3_oR-Fs0_7dWymovRY36aPOVb:dLI9AmUIrQBDh4jUmzNzh7Z61NA" alt="git three part"></p>
<p>第一部分就是“工作目录”，比如我们例子中GitRepo就是，你可以编辑的实际文档都在这里</p>
<p>第二部分就是“Index”区，或者也叫“Stage”区，也可以称之为“暂存区”，你可以将你的改动临时保存在这里</p>
<p>第三部分就是“HEAD”，当你提交之后，暂存区里头的内容就被提交到这里，git会在这里为你默认建立一个master分支，并让HEAD指向最后的一次提交</p>
<p>所以，之前我们提到的 git add 和 git commit 这两个常用命令，就是将这三部分串联起来的关键命令</p>
<p>git add 将你工作区的内容，添加到“暂存区”<br>git commit 就是将你“暂存区”的内容，再提交到当前分支上去</p>
<p>通常情况下，我们还会将代码再次提交到远端服务器上，这样可以让代码更加的安全，并且可以和团队中的其他人更好的进行协作，那么我们就需要用<code>git push</code>将代码从HEAD上再次推送到远端服务器上：<br>比如：</p>
<pre><code>git push origin master
</code></pre><p>我们可以将master换成是你需要的任何一个分支名</p>
<p>如果远端服务器上没有你的这个代码库，那么你可以通过：</p>
<pre><code>git remote add origin &lt;server&gt;
</code></pre><p>这个命令来在远端服务器上也建一个repo</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上文：<a href="http://comicoder.github.io/git%20step%20by%20step/2015/03/19/git%20step%20by%20step%2004/">git step by step4</a></p>]]>
    
    </summary>
    
      <category term="git" scheme="http://leeobarloon.github.io/tags/git/"/>
    
      <category term="git step by step" scheme="http://leeobarloon.github.io/categories/git-step-by-step/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git step by step 6 - git的恢复流程]]></title>
    <link href="http://leeobarloon.github.io/2015/03/23/git%20step%20by%20step%2006/"/>
    <id>http://leeobarloon.github.io/2015/03/23/git step by step 06/</id>
    <published>2015-03-22T16:00:00.000Z</published>
    <updated>2016-01-23T15:06:00.000Z</updated>
    <content type="html"><![CDATA[<p>接上文 <a href="http://comicoder.github.io/git%20step%20by%20step/2015/03/23/git%20step%20by%20step%2005/" target="_blank" rel="external">git step by step 05</a></p>
<a id="more"></a>
<h3 id="u7B2C_u4E00_u79CD_u60C5_u51B5_uFF0C_u6211_u4EEC_u4FEE_u6539_u4E86_u5DE5_u4F5C_u533A"><a href="#u7B2C_u4E00_u79CD_u60C5_u51B5_uFF0C_u6211_u4EEC_u4FEE_u6539_u4E86_u5DE5_u4F5C_u533A" class="headerlink" title="第一种情况，我们修改了工作区"></a>第一种情况，我们修改了工作区</h3><hr>
<p>当我们修改了工作区的文件内容，比如我们修改了例子中的<code>readme.md</code>文件内容：</p>
<pre><code>#This is a test
Hello GitHub
git is a great tool for coder...
</code></pre><p>修改为：</p>
<pre><code>#This is a test
Hello GitHub
git is a great tool for coder...
what hell！
</code></pre><p>后来我们发现最后一行写错了，那么我们怎么恢复呢？当然，你可以手动删掉最后一行，但是如果你的改动比较多，你也不知道改动了什么的时候，你就要借助git的力量</p>
<pre><code>git checkout -- filename
</code></pre><h3 id="u7B2C_u4E8C_u79CD_u60C5_u51B5_uFF0C_u6211_u4EEC_u5C06_u5DE5_u4F5C_u533A_u7684_u5185_u5BB9_u63D0_u4EA4_u5230_u4E86_u6682_u5B58_u533A"><a href="#u7B2C_u4E8C_u79CD_u60C5_u51B5_uFF0C_u6211_u4EEC_u5C06_u5DE5_u4F5C_u533A_u7684_u5185_u5BB9_u63D0_u4EA4_u5230_u4E86_u6682_u5B58_u533A" class="headerlink" title="第二种情况，我们将工作区的内容提交到了暂存区"></a>第二种情况，我们将工作区的内容提交到了暂存区</h3><hr>
<p>比如我们不小心还是将上述的文件修改成了带<code>what hell!</code>的文本，而且还用<code>git add</code> 命令将其提交到了暂存区，我们希望能够将这次修改恢复，如何处理呢？</p>
<p>没关系，你可以通过<code>git status</code>查看一下，git会有提示:</p>
<pre><code>On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

modified:   readme.md
</code></pre><p>你可以用reset HEAD <file>来unstage</file></p>
<p>你可以用 git reset HEAD readme.md，那么现在的状态就回到了第一种，即你的修改已经到了工作区了，那么，你就可以按照第一种情况所说的，使用<code>git checkout --readme.md</code>来恢复工作区即可</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上文 <a href="http://comicoder.github.io/git%20step%20by%20step/2015/03/23/git%20step%20by%20step%2005/">git step by step 05</a></p>]]>
    
    </summary>
    
      <category term="git" scheme="http://leeobarloon.github.io/tags/git/"/>
    
      <category term="git step by step" scheme="http://leeobarloon.github.io/categories/git-step-by-step/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git step by step 1 - git简介]]></title>
    <link href="http://leeobarloon.github.io/2015/03/20/git%20step-by-step%2001/"/>
    <id>http://leeobarloon.github.io/2015/03/20/git step-by-step 01/</id>
    <published>2015-03-20T07:58:55.000Z</published>
    <updated>2016-01-23T13:35:16.000Z</updated>
    <content type="html"><![CDATA[<p>很早就接触git，也有大名鼎鼎的github的账号，但一直以来都觉得git的命令实在不少，但自己主要用的就是那么几个，pull下来，push上去，其实说不上了解，顶多算略知皮毛，希望通过这个blog系列，可以让自己更多的了解git的精要，并且能够更好的和工作结合起来</p>
<a id="more"></a>
<h2 id="git_u4ECB_u7ECD"><a href="#git_u4ECB_u7ECD" class="headerlink" title="git介绍"></a>git介绍</h2><p>git是一个版本控制系统，在此之前程序员主要使用的基本上是SVN或者CVS等集中式的托管系统，但git改变了这一局面。<br>git的由来也富有传奇色彩，据说来源是这样的（以下摘自维基百科:<a href="http://zh.wikipedia.org/wiki/Git" target="_blank" rel="external">git</a>）：</p>
<pre><code>自2002年开始，林纳斯·托瓦兹决定使用BitKeeper作为Linux内核主要的版本控制系统，以此来维护代    码。2005年，BitKeeper的著作权拥有者，Larry MaVoy，宣称安德鲁·垂鸠曾试着以逆向工程手法来解    析BitKeeper内部使用的协议，因此决定收回使用BitKeeper的授权。Linux内核开发团队与BitMover公    司进行蹉商，但无法解决他们之间的歧见，林纳斯·托瓦兹决定自行开发版本控制系统，来替代    BitKeeper，于是编写出git
</code></pre><p>就这样，git改变了程序员的世界</p>
<p>git和以往的版本控制系统不同，它采取分布式的版本库的方法，不需要服务端软件，就可以运作版本控制，使得代码的管理和发布更加的简单。Git最有特点的功能就是它的合并追踪（Merge Tracing）的能力</p>
<h2 id="git_u7684_u7279_u70B9"><a href="#git_u7684_u7279_u70B9" class="headerlink" title="git的特点"></a>git的特点</h2><p>集中式和分布式的版本控制系统其简单对比如下：</p>
<p>###集中式<br>所谓集中式，就是指版本控制系统，需要一个中心服务器作为代码的存放地点，并负责维护代码的版本控制工作。</p>
<p>集中式的代码版本控制系统，有显而易见的缺点：</p>
<ol>
<li>依赖网络状况，如果网络出现异常，则对代码提交或check等工作都会造成影响</li>
<li>代码托管在一个集中的服务器上，一旦服务器出现异常，则会影响代码和版本信息，严重的情况下会出现代码丢失的问题！</li>
</ol>
<h3 id="u5206_u5E03_u5F0F"><a href="#u5206_u5E03_u5F0F" class="headerlink" title="分布式"></a>分布式</h3><p>分布式，没有客户端和服务端的区别，每一台机器就是一个服务器，在每一台机器上，都维护一套代码，并有代码的版本信息<br>分布式系统由于每一个机器都可以作为服务器，所以具有如下几个优点：</p>
<ol>
<li>支持离线工作，在网络情况不稳定的情况下，依旧可以在本机完成代码托管工作</li>
<li>安全性高，每一台机器都可以作为代码维护的节点，那么某些机器挂掉，也不会影响其他机器上代码</li>
</ol>
<p><strong>当然，一般git系统，也会使用一个集中的服务器作为大家代码托管代码的中心服务器，这样便于代码的共享以及协作。</strong></p>
<p>常见的提供git服务的网站：</p>
<p><a href="https://github.com" target="_blank" rel="external">github</a></p>
<p><a href="https://bitbucket.org/" target="_blank" rel="external">bitbucket</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>很早就接触git，也有大名鼎鼎的github的账号，但一直以来都觉得git的命令实在不少，但自己主要用的就是那么几个，pull下来，push上去，其实说不上了解，顶多算略知皮毛，希望通过这个blog系列，可以让自己更多的了解git的精要，并且能够更好的和工作结合起来</p>]]>
    
    </summary>
    
      <category term="git" scheme="http://leeobarloon.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git step by step 4 - git reset 的命令介绍]]></title>
    <link href="http://leeobarloon.github.io/2015/03/19/git-step-by-step-04/"/>
    <id>http://leeobarloon.github.io/2015/03/19/git-step-by-step-04/</id>
    <published>2015-03-18T16:00:00.000Z</published>
    <updated>2016-01-23T13:38:07.000Z</updated>
    <content type="html"><![CDATA[<p>接上文：<a href="http://comicoder.github.io/git%20step%20by%20step/2015/03/19/git%20step%20by%20step%2003/" target="_blank" rel="external">git step by step3</a></p>
<a id="more"></a>
<p>我们日常的工作中，对一个文件可能会有多次的修改和提交，很显然，我们肯定不能记住每一次的提交情况，git也提供了这个功能：</p>
<pre><code>git log
</code></pre><p>用这个命令，我们就可以看到每一次的提交情况：</p>
<pre><code>commit 905fe1cf74f9925abb548c5bf3f17ed62f0b4bfd
Author: ComiCoder &lt;glutinit@gmail.com&gt;
Date:   Thu Mar 19 17:57:03 2015 +0800

    add

commit 8790026bbc7687561c5065112f18a726ba313c38
Author: ComiCoder &lt;glutinit@gmail.com&gt;
Date:   Tue Mar 17 15:42:45 2015 +0800

    add a new file named readme.md
</code></pre><p>你也可以给<code>git log</code>加一个参数<code>--pretty=oneline</code>,这样，可以看到更简洁的log记录：</p>
<pre><code>905fe1cf74f9925abb548c5bf3f17ed62f0b4bfd add
8790026bbc7687561c5065112f18a726ba313c38 add a new file named readme.md
</code></pre><p>可以看到每一句话最开头的那长段id，就是每次的 <code>commit id</code></p>
<p>那么接下来，如果我们企图将上文中的 3月19日 的那个提交回退的话，我们应该如何做呢？很简单</p>
<pre><code>git reset --hard HEAD^
</code></pre><p>这样就行了，其中HEAD表示当前版本，那么HEAD^就表示上一个版本，HEAD^^自然就表示上上一个版本，<br>那么，往前回退N各版本，就输入<code>git reset --hard HEAD~N</code>即可</p>
<p>输入完<code>git reset --hard HEAD^</code>,我们再用 <code>git log</code>查看一下，发现，最近的一次提交没有了，我们已经会推到了上一个版本。</p>
<p>我们回退了之后后悔了咋办，也是有办法的，如果你的shell界面没有关闭，那么你还可以通过输入git reset –hard commitID的方法回复到你想要的版本，其中commitID不需要输全，你只需要输入前几个即可，git会帮你搜到，那么按照上面的git log的信息，我们就可以输入；</p>
<pre><code>git reset --hard 905fe1c
</code></pre><p>然后再用git log查看一下,哎，一切都恢复原状啦，你会发现git的回复速度很快，因为它只是将HEAD指向了你想要的那个版本上，并没有做删除的工作</p>
<p>另外，你还可以通过输入：<code>git reflog</code>来查看一下每一次的git 命令</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上文：<a href="http://comicoder.github.io/git%20step%20by%20step/2015/03/19/git%20step%20by%20step%2003/">git step by step3</a></p>]]>
    
    </summary>
    
      <category term="git" scheme="http://leeobarloon.github.io/tags/git/"/>
    
      <category term="git step by step" scheme="http://leeobarloon.github.io/categories/git-step-by-step/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python网络爬虫01]]></title>
    <link href="http://leeobarloon.github.io/2015/03/19/PythonWebRobot/"/>
    <id>http://leeobarloon.github.io/2015/03/19/PythonWebRobot/</id>
    <published>2015-03-18T16:00:00.000Z</published>
    <updated>2016-01-23T13:38:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近，一直在学习python和HTTP相关的一些知识，算是恶补之前一直没有太在意的内容，也早就听说python很适合写爬虫，那哥们儿也就凑凑热闹，写一个爬虫工具，爬爬看</p>
<a id="more"></a>
<p>在开始之前，我们先制定一个爬虫工具的目的，我们究竟要爬什么呢？我最近常去的网站就是<a href="http://huaban.com" target="_blank" rel="external">huaban.com</a>，我们就从花瓣上爬一些美女图片吧，哈哈</p>
<p>在写爬虫之前，我们必须了解一下python爬虫的基本知识，显而易见，首先你必须要会用python，第二，你必须对HTTP协议有一定的了解，在python中，和HTTP相关的两个库就是urllib和urllib2，也可以稍微走一些了解</p>
<p>##PYTHON<br>Python是一门很不错的语言，你既可以把它作为主要的开发语言，也可以作为辅助性的工具，走一些日常的批处理工作，对于我来说，目前我主要用python写了一个APP的服务端(基于Django框架)，我觉得比起java和java社区的Spring3框架，python更适合我个人，那么首先，介绍几各适合python入门的网站吧：</p>
<ol>
<li><a href="http://www.2cto.com/shouce/Pythonbbf/" target="_blank" rel="external">笨办法学python</a></li>
<li><a href="http://learnpythonthehardway.org/" target="_blank" rel="external">learn python the hard way 笨办法学python英文版</a></li>
<li><a href="/[A byte of Python](http://itlab.idcquan.com/linux/manual/python_chinese/">简明python教程</a></li>
<li><a href="http://www.swaroopch.com/notes/python/" target="_blank" rel="external">A Byte of Python</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="external">廖雪峰python教程</a></li>
</ol>
<p>看看上面几个基本上就没什么太大问题了，当然，python的内容还是很深入的，需要更进一步了解，就需要阅读更多的内容，多逛逛几个知名论坛等等</p>
<h2 id="urlib__u548C_urllib2"><a href="#urlib__u548C_urllib2" class="headerlink" title="urlib 和 urllib2"></a>urlib 和 urllib2</h2><p>这两个库是学习python 爬虫的最基本的两个库，最好也能够对它们有一定的了解和掌握</p>
<p>urllib：比较简单，功能相对也比较弱，可以从指定的URL下载文件，或是对一些字符串进行编码解码以使他们成为特定的 URL串。</p>
<p>urllib2：它有各种各样的Handler啊，Processor啊可以处理更复杂的问 题，比如网络认证，使用代理服务器，使用cookie等等。</p>
<h2 id="python_u7684_u6B63_u5219_u8868_u8FBE_u5F0F"><a href="#python_u7684_u6B63_u5219_u8868_u8FBE_u5F0F" class="headerlink" title="python的正则表达式"></a>python的正则表达式</h2><p>有了正则表达式，就可以更有效率地从抓取的网页信息中提炼你需要的内容，这个可以看看下面这篇文章：<br><a href="http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="external">Python正则表达式</a></p>
<p>##Scrapy<br>是一个python爬虫框架，最好在我们实现了最简单的python爬虫功能之后，再加以了解~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近，一直在学习python和HTTP相关的一些知识，算是恶补之前一直没有太在意的内容，也早就听说python很适合写爬虫，那哥们儿也就凑凑热闹，写一个爬虫工具，爬爬看</p>]]>
    
    </summary>
    
      <category term="Web" scheme="http://leeobarloon.github.io/tags/Web/"/>
    
      <category term="WebCrawler" scheme="http://leeobarloon.github.io/tags/WebCrawler/"/>
    
      <category term="python" scheme="http://leeobarloon.github.io/tags/python/"/>
    
      <category term="python爬虫" scheme="http://leeobarloon.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git step by step 3 - git简单操作]]></title>
    <link href="http://leeobarloon.github.io/2015/03/19/git%20step%20by%20step%2003/"/>
    <id>http://leeobarloon.github.io/2015/03/19/git step by step 03/</id>
    <published>2015-03-18T16:00:00.000Z</published>
    <updated>2016-01-23T13:37:35.000Z</updated>
    <content type="html"><![CDATA[<p>接上文<a href="http://comicoder.github.io/git%20step%20by%20step/2015/03/17/git%20step%20by%20step%2002/" target="_blank" rel="external">git step by step2</a></p>
<a id="more"></a>
<p>我们已经在我们的版本控制库中添加了readme.md文件，我们现在就来编辑一下它，将其修改为：</p>
<pre><code>#This is a test
Hello GitHub
git is a great tool for coder...
</code></pre><p>然后我们用<code>git status</code>命令查看一下</p>
<pre><code>$ git status

# On branch master
# Changes not staged for commit:
# ( use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

# modified:   readme.md

# no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre><p>从提示可以看出，该文档的内容已近被修改，git给我们两个选择，一个就是用git add 将此次修改提交到版本库，第二个就是用checkout – 恢复此次修改，我们可以试一下第二种</p>
<pre><code>git checkout -- readme.md
</code></pre><p>然后打开 readme.md，我们发现内容已近变成了之前的了…好把，那我们再重复一下上面的动作，修改文件，进行查看，然后我们可以用 <code>git diff</code>查看一下文件发生了什么变化.</p>
<pre><code>diff --git a/readme.md b/readme.md
index 76d2bc6..45e0d75 100644
--- a/readme.md
+++ b/readme.md
@@ -1,3 +1,3 @@
 #This is a test
-
-Hello Git Hub!
+Hello GitHub
+git is a great tool for coder...
</code></pre><p>可以看出，我们修改了 Hello Git Hub！这一行，并添加了 git is a …这一行</p>
<p>下面，我们就用<code>git add</code>将该文件提交到仓库吧</p>
<pre><code>git add readme.md
</code></pre><p>在commit之前，我们再用git status查看一下吧（注意git status是一个经常会用到的命令）</p>
<pre><code>On branch master
Changes to be committed:
    (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

modified:   readme.md
</code></pre><p>下面，就用git commit -m “xxxxx”</p>
<p>OK啦，这样就算最简单的git的使用喽</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上文<a href="http://comicoder.github.io/git%20step%20by%20step/2015/03/17/git%20step%20by%20step%2002/">git step by step2</a></p>]]>
    
    </summary>
    
      <category term="git" scheme="http://leeobarloon.github.io/tags/git/"/>
    
      <category term="git step by step" scheme="http://leeobarloon.github.io/categories/git-step-by-step/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux下面的简单页面配置]]></title>
    <link href="http://leeobarloon.github.io/2015/03/18/%E5%9C%A8linux%E4%B8%8A%E9%85%8D%E7%BD%AE%E7%BD%91%E7%AB%99/"/>
    <id>http://leeobarloon.github.io/2015/03/18/在linux上配置网站/</id>
    <published>2015-03-17T16:00:00.000Z</published>
    <updated>2016-01-23T13:37:10.000Z</updated>
    <content type="html"><![CDATA[<p>最近公司的网站域名通过了，我们打算先随便弄一个网站上去，就先从网上找了一个模板下来，改吧改吧就放上去了</p>
<a id="more"></a>
<p>但是，由于我忘了linxu上apache的 httpd.config文件放哪里了，所以就先用这个命令找一下：</p>
<pre><code>find / -name httpd.config -print
</code></pre><p>一下子就找到了，在我的系统上，这个配置文件在：<code>/etc/httpd/conf/</code> 下面:</p>
<p>然后我们找到下面有一个文件 httpd.config, 用vim打开，找到 <code>VirtualHost</code>:<br>可以看到类似的配置：</p>
<pre><code>&lt;VirtualBox ip:port&gt;
    ...
    DocumentRoot /xxx/xxx/xxx
    ...
&lt;/VirtualBox&gt;
</code></pre><p>将DocumentRoot修改成你自己网站所在的路径</p>
<p>然后重启apache：</p>
<pre><code>service httpd restart
</code></pre><p>然后就可以试试看喽</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近公司的网站域名通过了，我们打算先随便弄一个网站上去，就先从网上找了一个模板下来，改吧改吧就放上去了</p>]]>
    
    </summary>
    
      <category term="Web" scheme="http://leeobarloon.github.io/tags/Web/"/>
    
      <category term="linux" scheme="http://leeobarloon.github.io/tags/linux/"/>
    
      <category term="linux下的技术积累" scheme="http://leeobarloon.github.io/categories/linux%E4%B8%8B%E7%9A%84%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
</feed>
